import 'package:flutter/foundation.dart';import 'package:supabase_flutter/supabase_flutter.dart';import '../models/recipe.dart';class DataProvider with ChangeNotifier {  final SupabaseClient _client;  DataProvider(this._client);  /// Erstelle einen neuen Haushalt  Future createHousehold(String householdName, String userId, String color) async {    try {      final inviteCode = DateTime.now().millisecondsSinceEpoch.toString();      final households = await _client.from('households').insert({        'name': householdName,        'color': color,        'invite_code': inviteCode      }).select();      final data = households as List<dynamic>;      final householdId = data[0]['id'];      await _client.from('household_member').insert({        'household_id': householdId,        'member_uid': userId,      }).select();      notifyListeners();      return householdId;    } catch (e) {      throw Exception('Fehler beim Erstellen des Haushalts: $e');    }  }  /// Erhalte alle Haushalte, denen der aktuelle User angehört  Future<List<dynamic>> fetchUserHouseholds(String userId) async {    try {      final userHouseholdIds = await _client.from('household_member').select('household_id').eq('member_uid', userId) as List;      final households = await _client.from('households').select() as List;      final userHouseholds = households.where((household) => userHouseholdIds.any((userHousehold) => userHousehold['household_id'] == household['id'])).toList();      return userHouseholds;    } catch (e) {      throw Exception('Fehler beim Laden der Haushalte: $e');    }  }  /// Erhalte den aktuellen Haushalt  Future<Map<String, dynamic>> getCurrentHousehold(String householdId) async {    try {      final response = await _client.from('households').select().eq('id', householdId).single();      return response;    } catch (e) {      throw Exception('Fehler beim Laden des Haushalts: $e');    }  }  /// Aktualisiere die Daten des Haushalts  Future<void> updateHousehold(String householdId, {String? name, String? color}) async {    try {      final updateData = <String, dynamic>{};      if (name != null) updateData['name'] = name;      if (color != null) updateData['color'] = color;      try {        await _client.from('households').update(updateData).eq('id', householdId);        notifyListeners();      } catch (e) {        throw Exception('Fehler beim Aktualisieren des Haushalts: $e');      }    } catch (e) {      throw Exception('Fehler beim Aktualisieren des Haushalts: $e');    }  }  /// Lösche den Haushalt und alle Mitglieder  Future<void> deleteHousehold(String householdId) async {    try {      await _client.from('household_member').delete().eq('household_id', householdId);      await _client.from('households').delete().eq('id', householdId);      notifyListeners();    } catch (e) {      throw Exception('Fehler beim Löschen des Haushalts: $e');    }  }  /// Trete einem Haushalt bei  Future joinHousehold(String inviteCode, String userId) async {    try {      final response = await _client.from('households').select().eq('invite_code', inviteCode).single();      final householdId = response['id'];      final memberResponse = await _client.from('household_member').select().eq('household_id', householdId).eq('member_uid', userId).maybeSingle();      if (memberResponse == null) {        await _client.from('household_member').insert({          'household_id': householdId,          'member_uid': userId,        }).select();      }      notifyListeners();      return householdId;    } catch (e) {      throw Exception('Fehler beim Beitreten des Haushalts: $e');    }  }  Future<List<Map<String, dynamic>>> getHouseholdMembers(String householdId) async {    try {      final memberIdsResponse = await _client.from('household_member').select('member_uid').eq('household_id', householdId).select();      final List<dynamic> memberIds = memberIdsResponse;      final profilesResponse = await _client.from('profiles').select('id, username, email').select();      final List<dynamic> profiles = profilesResponse;      final userHouseholds = profiles.where((profile) => memberIds.any((member) => member['member_uid'] == profile['id'])).map((profile) => {'username': profile['username'], 'email': profile['email']}).toList();      return userHouseholds;    } catch (e) {      throw Exception('Fehler beim Laden der Haushaltsmitglieder: $e');    }  }  /// Rezeptverwaltungsmethoden  Future<Map<String, dynamic>> fetchRecipes(String householdId, {int page = 1, int limit = 10}) async {    try {      final int from = (page - 1) * limit;      final int to = from + limit - 1;      final response = await _client.from('recipes').select().eq('household_id', householdId).range(from, to).order('created_at', ascending: false);      final List<Recipe> recipes = (response as List).map((e) => Recipe.fromJson(e)).toList();      final int totalCount = response.length;      return {        'recipes': recipes,        'totalCount': totalCount,        'currentPage': page,        'totalPages': (totalCount / limit).ceil(),      };    } catch (e) {      throw Exception('Fehler beim Abrufen der Rezepte: $e');    }  }  Future<Recipe> fetchRecipeById(String recipeId) async {    try {      final response = await _client.from('recipes').select().eq('id', recipeId).single();      return Recipe.fromJson(response);    } catch (e) {      throw Exception('Fehler beim Abrufen des Rezepts: $e');    }  }  Future<void> createRecipe(Recipe recipe) async {    try {      await _client.from('recipes').insert(recipe.toJson());      notifyListeners();    } catch (e) {      throw Exception('Fehler beim Erstellen des Rezepts: $e');    }  }  Future<void> updateRecipe(Recipe recipe) async {    try {      await _client.from('recipes').update(recipe.toJson()).eq('id', recipe.id);      notifyListeners();    } catch (e) {      throw Exception('Fehler beim Aktualisieren des Rezepts: $e');    }  }  Future<void> deleteRecipe(String recipeId) async {    try {      await _client.from('recipes').delete().eq('id', recipeId);      notifyListeners();    } catch (e) {      throw Exception('Fehler beim Löschen des Rezepts: $e');    }  }  /// Hilfsmethode um aktuelle UserID zu bekommen  String getCurrentUserId() {    final user = _client.auth.currentUser;    if (user == null) {      throw Exception('Kein Benutzer ist derzeit angemeldet');    }    return user.id;  }}